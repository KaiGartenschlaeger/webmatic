import groovy.time.TimeCategory
import java.text.*
import mdz.ccuhistorian.Database

if (webServer.apiKeys)
    if (!params.k || !webServer.apiKeys.contains(params.k))
	throw new Exception('Access denied')	

// Aufrufparameter auswerten
if (!params.i || !params.i.integer)
    throw new Exception('Page parameter i (data point id) not set or invalid')

def dpId=params.i as Integer
def begin=utils.parseDate(params.b)
def duration=utils.parseDuration(params.d)
def end=utils.parseDate(params.e)
use (TimeCategory) {
    if (!begin) { 
	if (!end) end=new Date()
	if (!duration) begin=end-1
	else begin=end-duration
    } else { 
	if (!end) {
            if (!duration) end=new Date()
            else end=begin+duration
        }	
    }	
}

// Zeitreihe abfragen
def dataPoint=database.getDataPoint(dpId)
if (!dataPoint)
	throw new Exception("Data point with id $dpId not exists")
def timeSeries
if (database.isOfTypeString(dataPoint))
    timeSeries=database.getTimeSeriesRaw(dataPoint, begin, end)
else
    timeSeries=database.getTimeSeries(dataPoint, begin, end)
	
// JSON erstellen
def dateFormat=new SimpleDateFormat('dd.MM.yyyy HH:mm:ss')
def displayName=(dataPoint.attributes.displayName?:dataPoint.id.address)+'.'+dataPoint.id.identifier
def sb=new StringBuilder()

def valueFormatter
if (database.isOfTypeString(dataPoint)) {
    valueFormatter={ '"'+it.tr('"', '""')+'"' }
} else {
    def numberFormat=new DecimalFormat('#,##0.###')
    valueFormatter={ numberFormat.format(it.value) }
}
sb << '['
def comma = true
timeSeries.each {
    if(comma){
	comma = false
    }else{
	sb << ","
    }
    sb << '["' << dateFormat.format(it.timestamp) << '","' << valueFormatter(it.value) << '"]'
}
sb << ']'

// CSV-Datei verschicken
response.contentType='text/plain'
out << sb